安网3 SPOS共识算法V1.0(初稿)
==================

产块流程
--------

1.  程序启动时，开启一个定时器，定时器间隔设置为50毫秒一次；

2.  启动时，选取9个记账者；

3.  在定时器回调中，9个记账者轮流生成区块，1，2，3，4，5，\.....，9；

4.  一轮区块生成完后，重新选取9个记账者；

初始化
--------

<!-- -->

1.  在程序启动时，并且已经同步好主节点数据，做以下步骤；

2.  根据当前区块高度，往后开启查找，直到区块高度对9求余结果为0退出；

3.  按照1.2规则，从第2步开始选取9个记账者；

选取9个记账者
--------

<!-- -->

1.  在收到一个新的区块并且检验通过后，用区块链高度对9（记账者）求余，求余结果，如果不等于0，则直接返回，否则继续下面步骤；

2.  判断当前网络是否强制打开从官方主节点列表选择9个记账者，如果是，则从官方主节点列表中选取；否则从用户主节点列表中选取；

3.  从主节点列表（可能是：官方主节点列表、用户主节点列表）中选取出状态为Enabled、且在线时长大于3天的主节点，对选取出来的主节点按得分从大到小排序，计算得分规则：主节点抵押地址、当前链最新区块的时间生成一个HASH值，对HASH计算出一个整数，算法如下：

    uint32\_t static inline ReadLE32(const unsigned char\* ptr)

    {

    return le32toh(\*((uint32\_t\*)ptr));

    }

    arith\_uint256 UintToArith256(const uint256 &a)

    {

    arith\_uint256 b;

    for(int x=0; x\<b.WIDTH; ++x)

    b.pn\[x\] = ReadLE32(a.begin() + x\*4);

    return b;

    }

4.  从排好序的主节点列表中随机选择9个节点作为记账者，随机算法参考如下：

    auto now\_hi = uint64\_t(head\_block\_time().sec\_since\_epoch())
    \<\< 32;

    for( uint32\_t i = 0; i \<
    \_wso.current\_shuffled\_witnesses.size(); ++i )

    {

    /// High performance random generator

    /// http://xorshift.di.unimi.it/

    uint64\_t k = now\_hi + uint64\_t(i)\*2685821657736338717ULL;

    k \^= (k \>\> 12);

    k \^= (k \<\< 25);

    k \^= (k \>\> 27);

    k \*= 2685821657736338717ULL;

    uint32\_t jmax = \_wso.current\_shuffled\_witnesses.size() - i;

    uint32\_t j = i + k%jmax;

    std::swap( \_wso.current\_shuffled\_witnesses\[i\],

    \_wso.current\_shuffled\_witnesses\[j\] );

    }

    now\_hi的值由（用当前链最新区块的时间）\<\< 32计算出来

共识算法开关
--------

增加一个控制选取9个记账者开关，防止出现从用户主节点列表中选取出来9个记账者产生作恶的行为，导到不能产生区块。规则如下：

1.  增加Spork发送通知，打开强制从官方节点列表中选择9个记账者；规则如下：

2.  在代码中内置一些官方主节点列表；

3.  从官方主节点列表中选择9个记账者；

生成区块
--------

<!-- -->

1.  查看主节点是否有效的，并且是否已经同步好区块数据，如果不是，直接返回，否则继续下面步骤；

2.  获取到主节点的抵押地址，判断是否在9个记账者列表中，如果不存在，直接返回，否则继续下面步骤；

3.  获取本地时间，判断获取时间是否小于最新区块的时间，如果小于，直接返回，否则继续下面步骤；

4.  用获取到本地时间加上产块间隔时间，用它减去选取9个记账者所记录时间，得到的结果再除以产块时间间隔，除后得到的结果再对9求余，由此得到一个索引；

5.  用第4步计算得到的索引，在9个记账者列表中查找到计划产块时间、主节点抵押地址；

6.  判断主节点抵押地址是否与本节点主节点抵押地址一样，如果不一样，直接返回，否则继续下面步骤；

7.  用下一个产块时间减去第3步获取的时间，对得到结果取绝对值，判断是否大于500毫秒，如果大于，直接返回，否则打包区块并广播出去；

coinbase添加额外参数
--------------------

在coinbase交易输出字段中，增加以下两个字段：

1.  主节点的抵押地址；

2.  用主节点私钥对主节点抵押地址生成的签名；

修改区块参数
------------

区块中的nBits、nNonce修改为0；

启用SPOS
--------

在达到某个区块高度（比如：1200000）后，正式启用SPOS共识算法；

验证区块
--------

1.  收到一个区块，判断区块高度是否为大于等于1200000，如大于，增加以下规则判断；否则不判断以下规则；

2.  判断区块中nBits、nNonce是否为0；如果不是，拒绝此区块；否则继续下面步骤；

3.  获取到本地时间，用它减去区块中的时间，判断是否大于负10秒，如果大于，拒绝此区块；否则继续下面步骤；

4.  用区块中的主节点的抵押地址验证区块中的签名值，验证不通过，拒绝此区块，否则继续下面步骤；

5.  如果节点当前处于同步区块阶段，则直接到此验证完成，否则继续下面步骤；

6.  用区块中时间减去选取9个记账者所记录时间，得到的结果再除以产块时间间隔，除后得到的结果再对9求余，由此得到一个索引；

7.  通过索引在本地9个记账者列表中找到主节点的抵押址，判断它是否等于区块中的主节点的抵押地址，如果不相等，拒绝此区块；否则继续下面步骤；

产块超时如何处理
----------------

产块超时没有专门处理逻辑，因为产块定时器一直在运行，产块时间达到就会产生出来区块，如果异常产块节点在规定时间内未产生出区块，自动在下一个产块时间由下一个产块者产生区块。

如果异常产块节点在后面能够正常使用，进入到产块流程中，根据时间得到产块者就是它后面的节点了，只能在下一轮才能轮到它产块，因此就这样跳过了异常节点。

如何处理同一时刻多个区块
------------------------

1.  收到一个新的区块，判断当前区块中的前一个HASH是否为本地最新区块HASH；

2.  如果是，则直接加入到本地区块链； 否则，直接拒绝；

如果在同一时刻有多个区块产生，会产生以下情况：

1.  如果在某个时刻产生了两个区块，1个区块被其它节点认可并接受，其它节点占9个节点的三分之二；

2.  另1个区块被其它三分之一节点认可并接受，那么这时就形成了两个网络；

3.  这两个网络，随着时间增加不断的产块，最终在某个交汇处连接后，看哪条链最长，则会自动切换到最长的那条链；

4.  这里只举例说了一种情况，更复杂情况，请看"竞争链的问题"分析；

产块时间
--------

1.  产块时间，由原来2.5分钟改成10秒一个区块；

2.  区块奖励，根据产块时间调整区块奖励，新共识算法每个区块奖励比现有POW共识算法奖励要少，但每天产块个数增加了，等于每天所有奖励还是没有减少；

记账者挂了怎么办
----------------

1.  假如在9个记账者中有些节点挂掉了，那么如何开始下一轮重新选择9个记账者，采用的是重头再开始产块，这种方法，如果所有节点都挂了，就没有办法产块，但是这种极端概率发生非常小；

2.  假如9个记账者全部都挂了，官方可以多建立一些主节点保持网络的正常运行；
